---
title: "[Python] 파이썬 핵심"
excerpt: "<!--more-->"
categories:
  - Python
tags:
  - Python
  - 파이썬
  - 점프 투 파이썬
toc: true
toc_sticky: true
toc_label: "[TIL] 파이썬 핵심"
toc_icon: "bookmark"
---

# 5-1. 클래스

## 클래스는 왜 필요한가?

- 프로그래머들이 가장 많이 사용하는 프로그래밍 언어 중 하나인 **C 언어에는 클래스가 없음**
  - 굳이 클래스가 없어도 프로그램을 충분히 만들 수 있음
- 클래스는 지금까지 공부한 함수나 자료형처럼 프로그램 작성을 위해 꼭 필요한 요소는 아님
- 프로그램을 작성할 때 **클래스를 적재적소에 사용하면 얻을 수 있는 이익이 많음**

계산기의 "더하기" 기능을 구현한 파이썬 코드

```python
result = 0

def add(num):
    global result
    result += num
    return result

print(add(3))
print(add(4))
```

- 이전에 계산한 결괏값을 유지하기 위해서 result 전역 변수(global)를 사용

```python
3
7
```

- 만일 한 프로그램에서 2대의 계산기가 필요한 상황이 발생하면 각 계산기는 각각의 결괏값을 유지해야 하기 때문에 위와 같이 add 함수 하나만으로는 결괏값을 따로 유지할 수 없음
- 이런 상황을 해결하려면 다음과 같이 함수를 각각 따로 만들어야 함

## 클래스와 객체

- 과자 틀 → **클래스 (class)**
- 과자 틀에 의해서 만들어진 과자 → **객체 (object)**
- **클래스(class)**란 똑같은 무엇인가를 계속해서 만들어 낼 수 있는 설계 도면(과자 틀)
- **객체(object)**란 클래스로 만든 피조물(과자 틀을 사용해 만든 과자)
- 동일한 클래스로 만든 객체들은 **서로 전혀 영향을 주지 않음**

파이썬 클래스의 가장 간단한 예

```python
>>> class Cookie:
>>>    pass
```

- 객체는 클래스로 만들며 1개의 클래스는 무수히 많은 객체를 만들어 낼 수 있음

```python
>>> a = Cookie()
>>> b = Cookie()
```

- `Cookie()`의 결괏값을 돌려받은 a와 b가 바로 객체
-  마치 함수를 사용해서 그 결괏값을 돌려받는 모습과 비슷

**[객체와 인스턴스의 차이]**

- `a = Cookie()` 이렇게 만든 a는 **객체**
- 객체는 Cookie의 **인스턴스**
  - 즉 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용


## 사칙연산 클래스 만들기

**클래스를 어떻게 만들지 먼저 구상하기**

- 클래스로 만든 객체를 중심으로 어떤 식으로 동작하게 할것인지 미리 구상을 한 후에 생각한 것들을 하나씩 해결하면서 완성해 나가는 것이 좋음

사칙연산을 가능하게 하는 FourCal 클래스

- `a = FourCal()`를 입력해서 a라는 객체를 만듬

```python
>>> a = FourCal()
```

- `a.setdata(4, 2)`처럼 입력해서 숫자 4와 2를 a에 지정

```python
>>> a.setdata(4, 2)
```

- `a.add()`를 수행하면 두 수를 합한 결과(`4 + 2`)를 반환

```python
>>> print(a.add())
6
```

- `a.mul()`을 수행하면 두 수를 곱한 결과(`4 * 2`)를 반환

```python
>>> print(a.mul())
8
```

- `a.sub()`를 수행하면 두 수를 뺀 결과(`4 - 2`)를 반환

```python
>>> print(a.sub())
2
```

- `a.div()`를 수행하면 두 수를 나눈 결과(`4 / 2`)를 반환

```python
>>> print(a.div())
2
```

- 이렇게 동작하는 FourCal 클래스를 만드는 것이 목표

**클래스 구조 만들기**

- 동작하는 클래스를 만듬

```python
>>> class FourCal:
...     pass
... 
>>>
```

- 대화형 인터프리터에서 pass란 문장만을 포함한 FourCal 클래스를 만듬
- 현재 상태에서 FourCal 클래스는 아무 변수나 함수도 포함하지 않지만, 우리가 원하는 객체 a를 만들 수 있는 기능은 가지고 있음

> **pass**는 아무것도 수행하지 않는 문법으로 **임시로 코드를 작성**할 때 주로 사용함

```python
>>> a = FourCal()
>>> type(a)
<class '__main__.FourCal'>
```

> **type** 함수는 파이썬이 자체로 가지고 있는 **내장 함수로 객체 타입을 출력함**

**객체에 숫자 지정할 수 있게 만들기**

```python
>>> a.setdata(4, 2)
```

```python
>>> class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...
>>>
```

- FourCal 클래스에서 pass 문장을 삭제하고 그 대신 setdata 함수를 만듬
- 클래스 안에 구현된 함수는 **메서드**(Method)라고 부름
  - 클래스 내부의 함수는 항상 **메서드**라고 표현함

일반적인 함수

```python
def 함수명(매개변수):
    수행할 문장
    ...
```

- 메서드도 클래스에 포함되어 있다는 점만 제외하면 일반 함수와 같음

setdata 메서드

```python
def setdata(self, first, second):   # ① 메서드의 매개변수
    self.first = first              # ② 메서드의 수행문
    self.second = second            # ② 메서드의 수행문
```

**① setdata 메서드의 매개변수**

- setdata 메서드는 매개변수로 self, first, second 3개 입력값을 받음
- 일반 함수와는 달리 메서드의 첫 번째 매개변수 self는 특별한 의미를 가짐

a 객체를 만들고 a 객체를 통해 setdata 메서드를 호출

```python
>>> a = FourCal()
>>> a.setdata(4, 2)
```

> 객체를 통해 클래스의 메서드를 호출하려면 `a.setdata(4, 2`)와 같이 **도트(.) 연산자**를 사용

- setdata 메서드에는 self, first, second 총 3개의 매개변수가 필요한데 실제로는 `a.setdata(4, 2)`처럼 2개 값만 전달함
- 그 이유는 `a.setdata(4, 2)`처럼 호출하면 setdata 메서드의 첫 번째 매개변수 self에는 setdata메서드를 호출한 객체 a가 자동으로 전달됨

<img src="/images/python/object-call-process.png" width="500" height="400"/>

- 파이썬 메서드의 첫 번째 매개변수 이름은 **관례적으로 self**를 사용
- 객체를 호출할 때 호출한 객체 자신이 전달되기 때문에 self를 사용함
  - self말고 다른 이름을 사용해도 상관없음

> 메서드의 첫 번째 매개변수 self를 명시적으로 구현하는 것은 **파이썬만의 독특한 특징**
> **자바** 같은 언어는 **첫 번째 매개변수 self가 필요없음**

**[메서드의 또 다른 호출 방법]**

- 잘 사용하지는 않지만 다음과 같이 클래스를 통해 메서드를 호출하는 것도 가능

```python
>>> a = FourCal()
>>> FourCal.setdata(a, 4, 2)
```

- `클래스 이름.메서드` 형태로 호출할 때는 객체 a를 **첫 번째 매개변수 self에 꼭 전달**해줘야 함
- `객체.메서드` 형태로 호출할 때는 **self를 반드시 생략**해서 호출해야함

```python
>>> a = FourCal()
>>> a.setdata(4, 2)
```

**② setdata 메서드의 수행문**

```python
def setdata(self, first, second):   # ① 메서드의 매개변수
    self.first = first              # ② 메서드의 수행문
    self.second = second            # ② 메서드의 수행문
```

- `a.setdata(4, 2)`처럼 호출하면 setdata 메서드의 매개변수 first, second에는 각각 값 4와 2가 전달되어 setdata 메서드의 수행문은 다음과 같이 해석

```python
self.first = 4
self.second = 2
```

- self는 전달된 객체 a이므로 다시 다음과 같이 해석

```python
a.first = 4
a.second = 2
```

- `a.first = 4` 문장이 수행되면 a 객체에 객체변수 first가 생성되고 값 4가 저장됨
- 마찬가지로 `a.second = 2` 문장이 수행되면 a 객체에 객체변수 second가 생성되고 값 2가 저장

> 객체에 생성되는 객체만의 변수를 **객체변수**라고 함

```python
>>> a = FourCal()
>>> a.setdata(4, 2)
>>> print(a.first)
4
>>> print(a.second)
2
```

- a 객체에 객체변수 first와 second가 생성되었음을 확인할 수 있음

```python
>>> a = FourCal()
>>> b = FourCal()
```

- a 객체의 객체변수 first를 다음과 같이 생성

```python
>>> a.setdata(4, 2)
>>> print(a.first)
4
```

- b 객체의 객체변수 first를 다음과 같이 생성

```python
>>> b.setdata(3, 7)
>>> print(b.first)
3
```

- b 객체의 객체변수 first에는 값 3이 저장

```python
>>> print(a.first)
4
```

- a 객체의 first 값은 b 객체의 first 값에 영향받지 않고 원래 값을 유지
- 클래스로 만든 객체의 객체변수는 다른 객체의 객체변수에 상관없이 **독립적인 값을 유지**

- id 함수를 사용하면 객체변수가 독립적인 값을 유지한다는 점을 좀 더 명확하게 증명할 수 있음

> **id 함수**는 **객체의 주소**를 돌려주는 **파이썬 내장 함수**

```python
>>> a = FourCal()
>>> b = FourCal()
>>> a.setdata(4, 2)
>>> b.setdata(3, 7)
>>> id(a.first)   # a의 first 주소값을 확인
1839194944
>>> id(b.first)   # b의 first 주소값을 확인
1839194928
```

- a 객체의 first 주소 값과 b 객체의 first 주소 값이 서로 다르므로 각각 다른 곳에 그 값이 저장됨
- **객체변수는 그 객체의 고유 값을 저장할 수 있는 공간**
- 객체 변수는 다른 객체들 영향받지 않고 **독립적으로 그 값을 유지**한다는 점을 꼭 기억!
  - 클래스에서는 이 부분을 이해하는 것이 가장 중요


**더하기 기능 만들기**

```python
>>> a = FourCal()
>>> a.setdata(4, 2)
>>> print(a.add())
6
```

```python
>>> class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def add(self):
...         result = self.first + self.second
...         return result
...
>>>
```

- 새롭게 추가된 것은 add 메서드

```python
>>> a = FourCal()
>>> a.setdata(4, 2)
```

- a객체의 first, second 객체변수에는 각각 값 4와 2가 저장됨

- add 메서드를 호출

```python
>>> print(a.add())
>>> 6
```

- `a.add()`라고 호출하면 add 메서드가 호출되어 값 6이 출력됨

```python
def add(self):
    result = self.first + self.second
    return result
```

- add 메서드의 매개변수는 self이고 반환 값은 result
- 반환 값인 result를 계산하는 부분

```python
result = self.first + self.second
```

- `a.add()`와 같이 a 객체에 의해 add 메서드가 수행되면 add 메서드의 self에는 객체 a가 자동으로 입력되므로 위 내용은 다음과 같이 해석

```python
result = a.first + a.second
```

- `a.add()` 메서드 호출 전에 `a.setdata(4, 2)` 가 먼저 호출되어 `a.first = 4, a.second = 2` 라고 이미 설정되었기 때문에 다시 다음과 같이 해석

```python
result = 4 + 2
```

- `a.add()`를 호출하면 6을 반환

```python
>>> print(a.add())
6
```

**곱하기, 빼기, 나누기 기능 만들기**

```python
>>> class FourCal:
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def add(self):
...         result = self.first + self.second
...         return result
...     def mul(self):
...         result = self.first * self.second
...         return result
...     def sub(self):
...         result = self.first - self.second
...         return result
...     def div(self):
...         result = self.first / self.second
...         return result
...
>>>
```

```python
>>> a = FourCal()
>>> b = FourCal()
>>> a.setdata(4, 2)
>>> b.setdata(3, 8)
>>> a.add()
6
>>> a.mul()
8
>>> a.sub()
2
>>> a.div()
2
>>> b.add()
11
>>> b.mul()
24
>>> b.sub()
-5
>>> b.div()
0.375
```

## 생성자 (Constructor)

```python
>>> a = FourCal()
>>> a.add()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in add
AttributeError: 'FourCal' object has no attribute 'first'
```

- FourCal 클래스의 인스턴스 a에 setdata 메서드를 수행하지 않고 add 메서드를 수행하면 "AttributeError: 'FourCal' object has no attribute 'first'" 오류가 발생함
  -  setdata 메서드를 수행해야 객체 a의 객체변수 first와 second가 생성되기 때문

- 객체에 초깃값을 설정해야 할 필요가 있을 때는 setdata와 같은 메서드를 호출하여 초깃값을 설정하기보다는 생성자를 구현하는 것이 안전한 방법이다. 생성자(Constructor)란 객체가 생성될 때 자동으로 호출되는 메서드를 의미
- 파이썬 메서드 이름으로 `__init__`를 사용하면 이 메서드는 생성자

> `__init__` 메서드의 init 앞뒤로 붙은 `__`는 언더스코어(`_`) 두 개를 붙여씀

```python
>>> class FourCal:
...     def __init__(self, first, second):
...         self.first = first
...         self.second = second
...     def setdata(self, first, second):
...         self.first = first
...         self.second = second
...     def add(self):
...         result = self.first + self.second
...         return result
...     def mul(self):
...         result = self.first * self.second
...         return result
...     def sub(self):
...         result = self.first - self.second
...         return result
...     def div(self):
...         result = self.first / self.second
...         return result
...
>>>
```

생성자 `__init__` 메서드

```python
def __init__(self, first, second):
    self.first = first
    self.second = second
```

- `__init__` 메서드는 setdata 메서드와 이름만 다르고 모든 게 동일
- 단 메서드 이름을 `__init__`으로 했기 때문에 생성자로 인식되어 **객체가 생성되는 시점에 자동으로 호출**되는 차이가 있음

```python
>>> a = FourCal()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __init__() missing 2 required positional arguments: 'first' and 'second'
```

- `a = FourCal()`을 수행할 때 생성자 `__init__`이 호출되어 위와 같은 오류가 발생
  - 오류가 발생한 이유는 생성자의 매개변수 first와 second에 해당하는 값이 전달되지 않았기 때문

- 위 오류를 해결하려면 다음처럼 first와 second에 해당되는 값을 전달하여 객체를 생성해야 함

```python
>>> a = FourCal(4, 2)
>>> 
```

- `__init__` 메서드의 매개변수에는 각각 오른쪽과 같은 값이 대입

| 매개변수 | 값            |
| -------- | ------------- |
| self     | 생성되는 객체 |
| first    | 4             |
| second   | 2             |

> `__init__` 메서드도 다른 메서드와 마찬가지로 첫 번째 매개변수 self에 생성되는 객체가 자동으로 전달된다는 점을 기억하자.

- `__init__` 메서드가 호출되면 setdata 메서드를 호출했을 때와 마찬가지로 first와 second라는 객체변수가 생성

```python
>>> a = FourCal(4, 2)
>>> print(a.first)
4
>>> print(a.second)
2
```

```python
>>> a = FourCal(4, 2)
>>> a.add()
6
>>> a.div()
2.0
```

## 클래스의 상속

- 상속(Inheritance)이란 "물려받다", "재산을 상속받다"라고 할 때의 상속과 같은 의미
- 클래스에도 이 개념을 적용할 수 있음. 어떤 클래스를 만들 때 다른 클래스의 기능을 물려받을 수 있게 만들 수 있음
- 이번에는 상속 개념을 사용하여 우리가 만든 FourCal 클래스에 ab (a의 b제곱)을 구할 수 있는 기능을 추가
-  FourCal 클래스를 상속하는 MoreFourCal 클래스는 다음과 같이 간단하게 구현

```python
>>> class MoreFourCal(FourCal):
...     pass
... 
>>>
```

- 클래스를 상속하기 위해서는 다음처럼 클래스 이름 뒤 괄호 안에 상속할 클래스 이름을 넣어주면 됨

> **class 클래스 이름(상속할 클래스 이름)**

- MoreFourCal 클래스는 FourCal 클래스를 상속했으므로 FourCal 클래스의 모든 기능을 사용

```python
>>> a = MoreFourCal(4, 2)
>>> a.add()
6
>>> a.mul()
8
>>> a.sub()
2
>>> a.div()
2
```

- 상속받은 FourCal 클래스의 기능을 모두 사용할 수 있음을 확인할 수 있음

**왜 상속을 해야 할까?**

- 보통 상속은 기존 클래스를 변경하지 않고 기능을 추가하거나 기존 기능을 변경하려고 할 때 사용
- "클래스에 기능을 추가하고 싶으면 기존 클래스를 수정하면 되는데 왜 굳이 상속을 받아서 처리해야 하지?" 라는 의문이 들 수도 있음
  - 하지만 기존 클래스가 라이브러리 형태로 제공되거나 수정이 허용되지 않는 상황이라면 상속을 사용해야 함


a의 b제곱(ab)을 계산하는 MoreFourCal 클래스

```python
>>> class MoreFourCal(FourCal):
...     def pow(self):
...         result = self.first ** self.second
...         return result
...
>>>
```

- pass 문장은 삭제하고 위와 같이 두 수의 거듭제곱을 구할 수 있는 pow 메서드를 추가해 주었다. 그리고 다음과 같이 pow 메서드를 수행

```python
>>> a = MoreFourCal(4, 2)
>>> a.pow()
16
```

- MoreFourCal 클래스로 만든 a 객체에 값 4와 2를 설정한 후 pow 메서드를 호출하면 4의 2제곱 (42)인 16을 돌려주는 것을 확인할 수 있음

  상속은 MoreFourCal 클래스처럼 기존 클래스(FourCal)는 그대로 놔둔 채 클래스의 기능을 확장시킬 때 주로 사용

## 메서드 오버라이딩

```python
>>> a = FourCal(4, 0)
>>> a.div()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    result = self.first / self.second
ZeroDivisionError: division by zero
```

- FourCal 클래스의 객체 a에 4와 0 값을 설정하고 div 메서드를 호출하면 4를 0으로 나누려고 하기 때문에 위와 같은 ZeroDivisionError 오류가 발생
- 하지만 0으로 나눌 때 오류가 아닌 0을 돌려주도록 만들고 싶다면 어떻게 해야 할까?
- 다음과 같이 FourCal 클래스를 상속하는 SafeFourCal 클래스

```python
>>> class SafeFourCal(FourCal):
...     def div(self):
...         if self.second == 0:  # 나누는 값이 0인 경우 0을 리턴하도록 수정
...             return 0
...         else:
...             return self.first / self.second
...
>>>
```

- SafeFourCal 클래스는 FourCal 클래스에 있는 div 메서드를 동일한 이름으로 다시 작성하였음
- 이렇게 부모 클래스(상속한 클래스)에 있는 메서드를 동일한 이름으로 다시 만드는 것을 **메서드 오버라이딩**(Overriding, 덮어쓰기)이라고 함
- 이렇게 메서드를 오버라이딩하면 부모클래스의 메서드 대신 오버라이딩한 메서드가 호출됨
- SafeFourCal 클래스에 오버라이딩한 div 메서드는 나누는 값이 0인 경우에는 0을 돌려주도록 수정
- 이제 다시 위에서 수행한 예제를 FourCal 클래스 대신 SafeFourCal 클래스를 사용하여 수행

```python
>>> a = SafeFourCal(4, 0)
>>> a.div()
0
```

- FourCal 클래스와는 달리 ZeroDivisionError가 발생하지 않고 의도한 대로 0을 돌려주는 것을 확인할 수 있음

## 클래스 변수

- **객체변수**는 다른 객체들에 영향받지 않고 **독립적으로 그 값을 유지함**
- 객체변수와는 성격이 다른 **클래스 변수**

```python
>>> class Family:
...     lastname = "김"
...
```

- Family 클래스에 선언한 lastname이 바로 클래스 변수
- 클래스 변수는 클래스 안에 함수를 선언하는 것과 마찬가지로 클래스 안에 변수를 선언하여 생성

Family 클래스를 다음과 같이 사용해 보자.

```python
>>> print(Family.lastname)
김
```

- 클래스 변수는 위 예와 같이 `클래스이름.클래스 변수`로 사용할 수 있음
- 또는 다음과 같이 Family 클래스로 만든 객체를 통해서도 클래스 변수를 사용할 수 있음

```python
>>> a = Family()
>>> b = Family()
>>> print(a.lastname)
김
>>> print(b.lastname)
김
```

- 만약 Family 클래스의 lastname을 다음과 같이 "박"이라는 문자열로 바꾸면?

```python
>>> Family.lastname = "박"
```

```python
>>> print(a.lastname)
박
>>> print(b.lastname)
박
```

- 클래스 변수 값을 변경했더니 클래스로 만든 객체의 lastname 값도 모두 변경된다는 것을 확인할 수 있음
- 즉 클래스 변수는 클래스로 만든 모든 객체에 공유된다는 특징이 있음
- id 함수를 사용하면 클래스 변수가 공유됨

```python
>>> id(Family.lastname)
4480159136
>>> id(a.lastname)
4480159136
>>> id(b.lastname)
4480159136
```

- id 값이 모두 같으므로 `Family.lastname`, `a.lastname`, `b.lastname`은 모두 같은 메모리
- 클래스에서 클래스 변수보다는 객체변수가 훨씬 중요
  - 실무 프로그래밍을 할 때도 클래스 변수보다는 **객체변수**를 사용하는 비율이 훨씬 높음

# 5-2. 모듈

- 모듈이란 함수나 변수 또는 클래스를 모아 놓은 파일
- 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만든 파이썬 파일
- 파이썬으로 프로그래밍을 할 때 굉장히 많은 모듈을 사용함
- 다른 사람들이 이미 만들어 놓은 모듈을 사용할 수도 있고 직접 만들어서 사용할 수도 있음

## 모듈 생성

```python
# mod1.py
def add(a, b):
    return a + b

def sub(a, b): 
    return a-b
```

- add와 sub 함수만 있는 파일 mod1.py이 모듈

> **파이썬 확장자 .py로 만든 파이썬 파일은 모두 모듈**

## 모듈 불러오기

- 명령 프롬프트 창을 열고 mod1.py를 저장한 디렉터리로 이동한 다음 대화형 인터프리터를 실행

```python
> python
>>>
```

```python
>>> import mod1
>>> print(mod1.add(3, 4))
7
>>> print(mod1.sub(4, 2))
2
```

- mod1.py를 불러오기 위해 `import mod1`을 입력
  - 실수로 `import mod1.py`로 입력하지 않도록 주의
- **import는 이미 만들어 놓은 파이썬 모듈을 사용할 수 있게 해주는 명령어**
- mod1.py 파일에 있는 add 함수를 사용하기 위해서는 위 예와 같이 `mod1.add`처럼 모듈 이름 뒤에 **"."(도트 연산자)**를 붙이고 함수 이름을 쓰면됨

> import는 **현재 디렉터리에 있는 파일이나 파이썬 라이브러리가 저장된 디렉터리에 있는 모듈만** 불러올 수 있음
> 파이썬 라이브러리는 파이썬을 설치할 때 자동으로 설치되는 파이썬 모듈을 말함

import의 사용 방법

```python
import 모듈이름
```

- 모듈 이름은 mod1.py에서 .py 확장자를 제거한 mod1만 적어야 함
  - **확장자를 제거한 모듈이름만 적어야 함**

- `mod1.add`, `mod1.sub`처럼 쓰지 않고 `add`, `sub`처럼 모듈 이름 없이 함수 이름만 쓰고 싶은 경우 **"from 모듈 이름 import 모듈 함수"**를 사용하면됨

```python
from 모듈이름 import 모듈함수
```

- 위 형식을 사용하면 위와 같이 모듈 이름을 붙이지 않고 바로 해당 모듈의 함수를 쓸 수 있음

```python
>>> from mod1 import add
>>> add(3, 4)
7
```

- 위와 같이 하면 mod1.py 파일의 add 함수만 사용할 수 있음

add 함수와 sub 함수를 둘 다 사용하기 위한 2가지 방법

```python
from mod1 import add, sub
```

- 첫 번째 방법은 from 모듈 이름 import 모듈 함수1, 모듈 함수2처럼 사용
- **콤마로 구분**하여 필요한 함수를 불러올 수 있음

```python
from mod1 import *
```

- 두 번째 방법은 위와 같이 **`*` 문자를 사용하는 방법**
- `*` 문자는 "모든 것"이라는 뜻인데 파이썬에서도 마찬가지 의미로 사용됨
- `from mod1 import *`는 mod1.py의 모든 함수를 불러서 사용하겠다는 뜻

## if \_\_name\_\_ == "\_\_main\_\_": 의 의미

```python
# mod1.py 
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

print(add(1, 4))
print(sub(4, 2))
```

- `add(1, 4)`와 `sub(4, 2)`의 결과를 출력하는 다음 문장을 추가함
- mod1.py 파일은 다음과 같이 실행할 수 있음

```python
> python mod1.py
5
2
```

- mod1.py 파일의 add와 sub 함수를 사용하기 위해 mod1 모듈을 import할 때는 좀 이상한 문제가 생김

```python
> python
Type "help", "copyright", "credits" or "license" for more information.
>>> import mod1
5
2
```

- 단지 mod1.py 파일의 add와 sub 함수만 사용하려고 했는데 import mod1을 수행하는 순간 mod1.py가 실행이 되어 결괏값을 출력함
- 이러한 문제를 방지하려면 mod1.py 파일을 다음처럼 변경해야함

```python
# mod1.py 
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

if __name__ == "__main__":
    print(add(1, 4))
    print(sub(4, 2))
```

- `if __name__ == "__main__"`을 사용하면 `> python mod1.py`처럼 직접 이 파일을 실행했을 때는 `__name__ == "__main__"`이 참이 되어 if문 다음 문장이 수행됨
- 반대로 대화형 인터프리터나 다른 파일에서 이 모듈을 불러서 사용할 때는 `__name__ == "__main__"`이 거짓이 되어 if문 다음 문장이 수행되지 않음
- 위와 같이 수정한 후 다시 대화형 인터프리터를 열고 실행하면 아무 결괏값도 출력되지 않는 것을 확인할 수 있음

```python
>>> import mod1
>>>
```

**`__name__` 변수란?**

- 파이썬의 `__name__` 변수는 파이썬이 내부적으로 사용하는 특별한 변수 이름
- 만약 `> python mod1.py`처럼 직접 mod1.py 파일을 실행할 경우 mod1.py의 `__name__` 변수에는 `__main__` 값이 저장됨
- 하지만 **파이썬 셸이나 다른 파이썬 모듈**에서 mod1을 import 할 경우에는 mod1.py의 `__name__` 변수에는 mod1.py의 **모듈 이름** 값 mod1이 저장됨

```python
>>> import mod1
>>> mod1.__name__
'mod1'
```

## 클래스나 변수 등을 포함한 모듈

- 모듈은 함수만 포함했지만 클래스나 변수 등을 포함할 수 있음

```python
# mod2.py 
PI = 3.141592	# 변수

class Math:		# 클래스
    def solv(self, r): 
        return PI * (r ** 2) 

def add(a, b): 	# 함수
    return a+b 
```

- 이 파일은 원의 넓이를 계산하는 Math 클래스와 두 값을 더하는 add 함수 그리고 원주율 값에 해당되는 PI 변수처럼 클래스, 함수, 변수 등을 모두 포함하고 있음

```python
> python
Type "help", "copyright", "credits" or "license" for more information.
>>> import mod2
>>> print(mod2.PI)
3.141592
```

-  `mod2.PI`처럼 입력해서 mod2.py 파일에 있는 PI 변수 값을 사용할 수 있음

```python
>>> a = mod2.Math()
>>> print(a.solv(2))
12.566368
```

- mod2.py에 있는 Math 클래스를 사용하는 방법을 보여줌
- 위 예처럼 **모듈 안에 있는 클래스를 사용하려면 "."(도트 연산자)로 클래스 이름 앞에 모듈 이름을 먼저 입력**해야 함

```python
>>> print(mod2.add(mod2.PI, 4.4))
7.541592
```

- mod2.py에 있는 add 함수 역시 당연히 사용할 수 있음

## 다른 파일에서 모듈 불러오기

- 지금까지는 만들어 놓은 모듈 파일을 사용하기 위해 대화형 인터프리터만 사용함

다른 파이썬 파일에서 이전에 만들어 놓은 모듈을 불러와서 사용하는 방법

- 조금 전에 만든 모듈인 mod2.py 파일을 다른 파이썬 파일에서 불러와 사용할 것임
- 에디터로 `modtest.py` 파일을 다음과 같이 작성

```python
# modtest.py
import mod2
result = mod2.add(3, 4)
print(result)
```

- 다른 파이썬 파일에서도 import mod2로 mod2 모듈을 불러와서 사용할 수 있음
  - 대화형 인터프리터에서 한 것과 마찬가지 방법임
- 위 예제가 정상적으로 실행되기 위해서는 modtest.py 파일과 mod2.py 파일이 **동일한 디렉터리**에 있어야 함

**[모듈을 불러오는 또 다른 방법]**

- 지금껏 명령 프롬프트 창을 열고 모듈이 있는 디렉터리로 이동한 다음에 모듈을 사용할 수 있었음
- 이번에는 모듈을 저장한 디렉터리로 이동하지 않고 모듈을 불러와서 사용하는 방법

**1. sys.path.append(모듈을 저장한 디렉터리) 사용하기**

- 먼저 **sys 모듈**을 불러옴

```
> python
>>> import sys
```

- sys 모듈은 파이썬을 설치할 때 함께 설치되는 라이브러리 모듈
- sys 모듈을 사용하면 파이썬 라이브러리가 설치되어 있는 디렉터리를 확인할 수 있음

```
>>> sys.path
['', 'C:\\Windows\\SYSTEM32\\python37.zip', 'c:\\Python37\\DLLs', 
'c:\\Python37\\lib', 'c:\\Python37', 'c:\\Python37\\lib\\site-packages']
```

- `sys.path`는 파이썬 라이브러리가 설치되어 있는 디렉터리를 보여 줌
- 만약 파이썬 모듈이 위 디렉터리에 들어 있다면 모듈이 저장된 디렉터리로 이동할 필요 없이 바로 불러서 사용할 수 있음
  - 그렇다면 `sys.path`에 디렉터리를 추가하면 아무 곳에서나 불러 사용할 수 있음

> 명령 프롬프트 창에서는 `/`, `\`든 상관없지만, 소스 코드 안에서는 반드시 `/` 또는 `\\` 기호를 사용해야 함

- sys.path의 결괏값이 리스트이므로 다음과 같이 할 수 있음

```
>>> sys.path.append("C:/doit/mymod")
>>> sys.path
['', 'C:\\Windows\\SYSTEM32\\python37.zip', 'c:\\Python37\\DLLs', 
'c:\\Python37\\lib', 'c:\\Python37', 'c:\\Python37\\lib\\site-packages', 
'C:/doit/mymod']
>>>
```

- sys.path.append를 사용해서 `C:/doit/mymod`라는 디렉터리를 sys.path에 추가한 후 다시 `sys.path`를 보면 가장 마지막 요소에 `C:/doit/mymod`라고 추가된 것을 확인할 수 있음

```
>>> import mod2
>>> print(mod2.add(3,4))
7
```

- 실제로 모듈을 이상 없이 불러와서 사용할 수 있음

**2. PYTHONPATH 환경 변수 사용하기**

- 모듈을 불러와서 사용하는 또 다른 방법으로는 `PYTHONPATH` 환경 변수를 사용하는 방법

```
C:\doit>set PYTHONPATH=C:\doit\mymod
C:\doit>python
>>> import mod2
>>> print(mod2.add(3,4))
7
```

- set 명령어를 사용해 `PYTHONPATH` 환경 변수에 mod2.py 파일이 있는 `C:\doit\mymod` 디렉터리를 설정
- 그러면 디렉터리 이동이나 별도의 모듈 추가 작업 없이 mod2 모듈을 불러와서 사용할 수 있음

# References

> [점프 투 파이썬](https://wikidocs.net/book/1)